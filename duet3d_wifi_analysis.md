# WiFiSocketServerRTOS: Connection Stability Analysis and Fixes

## Executive Summary

This report documents the investigation and resolution of a critical connection stability issue in the Duet3D WiFiSocketServerRTOS firmware for the ESP8266. Under load — specifically when one client uploads a file while multiple Duet Web Control (DWC) clients poll for status updates — all TCP connections would suddenly collapse, terminating the file upload and disconnecting all clients.

Root cause analysis revealed that the connection close mechanism (`closePending`) held lwIP TCP PCBs and connection slots for up to 4 seconds per close, waiting for TCP acknowledgements that were rendered irrelevant by client-side connection resets. Under the connection churn generated by DWC polling (~12 connections/second), this resource holding exhausted lwIP's finite PCB pool, causing lwIP to forcibly kill existing connections — including the long-lived file upload — via `tcp_kill_prio()`.

The fix was to remove the `closePending` mechanism entirely and close connections immediately, along with several additional robustness improvements to the connection and listener subsystems.

---

## 1. System Architecture

### 1.1 Hardware and Software Stack

- **MCU**: ESP8266 running ESP8266 RTOS SDK with FreeRTOS
- **Network Stack**: lwIP (netconn API)
- **Communication**: SPI link to SAM processor (Duet mainboard running RepRapFirmware)
- **Role**: The ESP8266 acts as a WiFi-to-SPI bridge, accepting TCP connections from web clients and forwarding data to/from RepRapFirmware (RRF) over SPI

### 1.2 Connection Management

The firmware manages up to 8 simultaneous TCP connections (`MaxConnections = 8`). Each connection progresses through a state machine defined in `MessageFormats.h`:

```
free → allocated → connected → otherEndClosed → free
                           ↘ aborted → (external terminate) → free
```

Key components:
- **`Connection` class** (`Connection.cpp`): Manages individual TCP connections — read, write, poll, close, terminate
- **`Listener` class** (`Listener.cpp`): Manages TCP listeners using FreeRTOS task notifications to wake the listener task on new connections
- **`SocketServer`** (`SocketServer.cpp`): Main loop handling SPI communication with the SAM processor, connection polling, and command dispatch

### 1.3 lwIP Configuration (ESP8266)

| Parameter | Value |
|-----------|-------|
| `CONFIG_LWIP_MAX_SOCKETS` | 16 |
| `MEMP_NUM_TCP_PCB` | ~10 (ESP8266 default, not explicitly configured) |
| `TCP_SND_BUF` | 7,300 bytes |
| `TCP_WND` | 7,300 bytes |
| `TCP_MSS` | 1,460 bytes |
| `Backlog` | 8 |

Each active TCP connection consumes approximately 14.6 KB in send/receive buffers, plus one TCP PCB from lwIP's pre-allocated pool.

### 1.4 Typical Workload

The scenario under investigation:
- **1 file upload**: Long-lived HTTP POST connection (conn 1), sustained data transfer from client to ESP
- **Multiple DWC clients** (up to 7): Each client polls RRF for status updates via short-lived HTTP GET requests at intervals of a few hundred milliseconds
- **1 API client**: Additional status polling

Each DWC status poll creates a new TCP connection, sends an HTTP GET, receives the JSON response, and closes the connection. With multiple DWC clients, this produces a sustained connection churn rate of ~12 connections/second on the ESP.

---

## 2. Problem Statement

### 2.1 Observed Symptom

During a file upload with multiple DWC clients connected, all TCP connections would suddenly terminate simultaneously. The file upload was aborted, and all DWC clients lost connectivity. The ESP's serial debug output showed cascading errors across all connection slots.

### 2.2 Initial Debug Log Analysis (pre-fix)

The first debug log (`output_2026-02-19_09-53-39.log`, ~11K lines) revealed:

1. **Connection 1 stuck in `aborted` state**: After an internal error, `Terminate(false)` set the connection to `aborted`, but RRF never acknowledged it, creating a zombie that permanently consumed a connection slot.

2. **closePending race condition**: `netconn_shutdown()` could cause lwIP to free the TCP PCB (if the remote end had already RST/FIN'd), but the code unconditionally entered `closePending` regardless, entering a doomed wait on a freed PCB.

3. **Spurious accept failures** (`rc=-7`, ERR_WOULDBLOCK): `Connection::Close()` called `listener->Notify()` every time a connection slot was freed. This woke the listener task which attempted `netconn_accept()` even though no new connection was pending in the backlog.

4. **Garbled debug output**: The `debugPrintf` macro expands to two separate `ets_printf()` calls (file/line prefix, then the message). Multiple FreeRTOS tasks printing concurrently produced interleaved, garbled output.

---

## 3. Bugs Identified and Fixed

### 3.1 Inverted NETCONN_MORE Flag

**File**: `Connection.cpp`, `Write()`
**Commit**: `fc57d05`

The TCP write flag logic was inverted:

```cpp
// BEFORE (incorrect):
u8_t flag = NETCONN_COPY | (push ? NETCONN_MORE : 0);

// AFTER (correct):
u8_t flag = NETCONN_COPY | (push ? 0 : NETCONN_MORE);
```

`NETCONN_MORE` tells lwIP that more data will follow, enabling TCP segment coalescing (Nagle-like behavior). The inverted logic set `NETCONN_MORE` when pushing (final segment) and cleared it when more data was coming — the exact opposite of correct behavior. This caused unnecessary packet fragmentation on multi-segment writes and premature flushing.

### 3.2 Write() Spin Loop on ERR_WOULDBLOCK

**File**: `Connection.cpp`, `Write()`
**Commit**: `feb9fe1`

When `netconn_write_partly()` returned `ERR_WOULDBLOCK` with `written == 0` (send buffer completely full, no bytes written despite the 2-second timeout), the write loop would retry indefinitely, spinning the CPU without making progress.

```cpp
// FIX: Break when no progress is possible
if (rc == ERR_WOULDBLOCK && written == 0) {
    break;  // send buffer full, avoid spinning
}
```

### 3.3 Write() Incorrect Return Value

**File**: `Connection.cpp`, `Write()`
**Commit**: `feb9fe1`

`Write()` returned `length` (the requested amount) instead of `total` (the actual bytes written). When a partial write occurred, the caller (RRF) believed all data was sent, causing silent data loss.

```cpp
// BEFORE: return length;  // lies about bytes written
// AFTER:  return total;   // actual bytes written
```

### 3.4 Unhandled ERR_ABRT and ERR_TIMEOUT in Poll() and Write()

**File**: `Connection.cpp`, `Poll()` and `Write()`
**Commit**: `feb9fe1`

lwIP can return `ERR_ABRT` when it internally aborts a connection under memory pressure, and `ERR_TIMEOUT` on receive timeout. Neither was recognized:

```cpp
// Poll() - added ERR_TIMEOUT and ERR_ABRT handling:
if (rc != ERR_WOULDBLOCK && rc != ERR_TIMEOUT)
{
    if (rc == ERR_RST || rc == ERR_CLSD || rc == ERR_CONN || rc == ERR_ABRT)

// Write() - added ERR_ABRT:
if (rc == ERR_RST || rc == ERR_CLSD || rc == ERR_ABRT)
```

Without this, `ERR_ABRT` fell through to `Terminate(false)` in `Poll()`, creating zombie aborted connections. `ERR_TIMEOUT` was logged as an error when it was a normal non-blocking return.

### 3.5 Connect() Incorrect Return Value

**File**: `Connection.cpp`, `Connect()`
**Commit**: `feb9fe1`

The failure path returned `true` instead of `false`:

```cpp
// BEFORE: return true;   // claimed success on failure
// AFTER:  return false;
```

### 3.6 Allocate() Mutex Safety

**File**: `Connection.cpp`, `Allocate()`
**Commit**: `feb9fe1`

`xSemaphoreTake(allocateMutex, portMAX_DELAY)` could block indefinitely if the mutex was never released (e.g., due to a crash in the holding task). Also, no null check on the mutex handle.

```cpp
// FIX: Null check and bounded timeout
if (!allocateMutex) { return nullptr; }
if (xSemaphoreTake(allocateMutex, pdMS_TO_TICKS(200)) != pdTRUE) { return nullptr; }
```

### 3.7 Listener::Stop() Use-After-Free

**File**: `Listener.cpp`, `Stop()`
**Commit**: `feb9fe1`

`Stop()` called `netconn_close(conn)` and `netconn_delete(conn)`, then iterated listeners comparing `listener->conn == conn`. After `netconn_delete()`, the `conn` pointer is dangling — the comparison is undefined behavior.

```cpp
// FIX: Save conn before close/delete
void Listener::Stop()
{
    struct netconn *savedConn = conn;
    netconn_close(savedConn);
    netconn_delete(savedConn);
    for (int i = 0; i < MaxConnections; i++)
    {
        Listener *listener = listeners[i];
        if (listener && listener->conn == savedConn)
        {
            delete listener;
            listeners[i] = nullptr;
        }
    }
}
```

### 3.8 FTP Data Listener Use-After-Free

**File**: `Listener.cpp`, `ListenerTask()`
**Commit**: `feb9fe1`

When accepting an FTP data connection, `listener->Stop()` was called to stop listening for further connections. But `Stop()` deletes the listener object, and the accepted connection still held a `listener` pointer — a use-after-free.

```cpp
// FIX: Clear the connection's listener pointer before Stop() deletes it
c->listener = nullptr;
listener->Stop();
```

### 3.9 Listener Null Safety in Close() and Terminate()

**File**: `Connection.cpp`, `Close()` and `Terminate()`
**Commit**: `feb9fe1`

Both methods called `listener->Notify()` without checking if `listener` was null. After the FTP use-after-free fix (which sets `listener = nullptr`), this would crash.

```cpp
// FIX:
if (external && listener)
{
    listener->Notify();
}
```

### 3.10 Rejected Connections Not Drained from Accept Backlog

**File**: `Listener.cpp`, `ListenerTask()`
**Commit**: `feb9fe1`

When a connection was rejected (either no free connection slots or too many connections on the port), the pending connection remained in lwIP's accept backlog, consuming a TCP PCB indefinitely.

```cpp
// FIX: Accept and immediately close to free the PCB
struct netconn *newConn;
if (netconn_accept(listener->conn, &newConn) == ERR_OK)
{
    netconn_close(newConn);
    netconn_delete(newConn);
}
```

### 3.11 Diagnostics Command Blocking the Main Loop

**File**: `SocketServer.cpp`, deferred command handler
**Commit**: `0f7b3f0`

The M122 diagnostics command was handled as a deferred command in the main SPI loop:

```cpp
case NetworkCommand::diagnostics:
    Connection::ReportConnections();
    delay(20);          // blocked the main loop for 20ms
    stats_display();    // lwIP stats — very verbose UART output
    break;
```

`stats_display()` is an lwIP function that dumps extensive protocol statistics over UART at 74,880 baud. Combined with the 20ms delay, this blocked the main loop long enough to cause SPI communication timeouts with the SAM processor. During this time, no connection polling occurred and no SPI requests could be processed, causing the SAM to report `SPI timeout` errors.

**Fix**: Removed `delay(20)` and `stats_display()`. `ReportConnections()` alone provides sufficient diagnostic information without blocking the main loop.

---

## 4. The Core Issue: closePending and PCB Exhaustion

### 4.1 How closePending Worked (Before Removal)

When RRF requested a connection close while TCP data was still unacknowledged (in the `unacked` queue of the TCP PCB), the connection entered the `closePending` state:

```
Close() called while state == connected:
  1. netconn_shutdown(conn, true, false)    // shutdown receive side only
  2. Check conn->pcb.tcp->unacked
  3. If unacked data exists → SetState(closePending)
  4. Poll() checks periodically:
     a. If PCB lost (freed by lwIP)    → closeReady → Close() → free
     b. If unacked queue empty (ACK'd) → closeReady
     c. If 4 seconds elapsed           → Terminate(false) → aborted
```

### 4.2 Why closePending Was Counterproductive

For DWC HTTP status polling connections, the TCP flow is:

```
T=0ms    Server sends HTTP response (data enters lwIP unacked queue)
T=0ms    RRF calls connClose → Close() → enters closePending
T=~50ms  Client TCP stack receives the response data
T=~50ms  Client TCP stack queues a delayed ACK (40-200ms timer)
T=~55ms  Browser finishes processing the response, calls close() on socket
T=~56ms  Client sends RST (abortive close — cancels the pending delayed ACK)
T=~57ms  lwIP receives RST → frees the TCP PCB
         → "PCB lost during closePending"
```

The delayed ACK that was queued at T=50ms is **never sent** because the client's `close()` at T=55ms triggers a RST that preempts it. The client sends RST (rather than a graceful FIN) because either:
- The browser uses `SO_LINGER` with timeout 0 to avoid TIME_WAIT state
- There is unread data in the client's receive buffer at close time
- The browser performs an abortive close for performance

The closePending mechanism thus waited for an ACK that would never arrive, because the client had already received the data, processed it, and torn down the connection. The data delivery was never in question — only the TCP bookkeeping ACK, which was a formality rendered moot by the RST.

### 4.3 Resource Exhaustion Under DWC Churn

Debug log analysis (`output3-debug.txt`, 9,870 lines) of a session with one file upload and multiple DWC clients revealed:

| Metric | Value |
|--------|-------|
| Session duration analyzed | ~60 seconds |
| Upload connection | conn 1, port 56238, alive for 59 seconds |
| "PCB lost during closePending" events | **736** (489 on conn 0) |
| "accept failed rc=-7" events | **671** |
| Lowest free heap | **32,952 bytes** |
| Connection churn rate | ~12 connections/second |

Each closePending connection held:
- A connection slot (1 of 8 available)
- A `netconn` struct with its receive mailbox
- A TCP PCB (1 of ~10 available in lwIP's MEMP pool)
- Send/receive buffers (~14.6 KB per connection)

With 12 connections/second churning through closePending, and lwIP's `MEMP_NUM_TCP_PCB` pool at approximately 10 PCBs:

```
Active PCBs at any moment:
  Listener PCBs:          1-2
  Upload connection:      1
  Active DWC connections: 1-3
  closePending:           1-2
  Accept backlog:         0-8 (Backlog=8)
  ─────────────────────────────
  Total:                  4-16   (max of ~10 available)
```

When total PCB demand exceeded the pool size, lwIP's `tcp_alloc()` failed and invoked `tcp_kill_prio()`, which kills the lowest-priority existing connection to reclaim a PCB. Since all connections run at default priority 0, lwIP selects the oldest connection — **the file upload** (conn 1, alive for 59 seconds).

The kill event in the log:

```
line 8249: conn 1: poll recv rc=-14 state=2    ← ERR_RST (connection reset)
line 8250: conn 1: poll recv rc=-14 state=3    ← now otherEndClosed
line 8251: conn 1: poll recv rc=-11 state=3    ← ERR_CONN (PCB already gone)
line 8255: conn 1: terminate external=1 state=3 ← RRF cleans up the dead connection
```

The upload connection was killed not by its client, but by lwIP reclaiming its PCB to serve a new DWC polling connection.

### 4.4 Spurious Listener Notifications Compounding the Problem

`Connection::Close()` called `listener->Notify()` every time a connection slot was freed. This set the same FreeRTOS task notification bit as `ListenCallback` (which fires for genuinely new incoming connections). The listener task could not distinguish between "new connection available" and "slot freed" notifications.

Each spurious notification caused:
1. ListenerTask wakeup
2. `Connection::Allocate()` — mutex acquisition + slot scan
3. `netconn_accept()` — syscall into lwIP (returns `ERR_WOULDBLOCK`, nothing to accept)
4. `Connection::Deallocate()` — release the slot

With ~12 connection closes per second, this added ~12 unnecessary wake-up/allocate/accept/deallocate cycles per second — pure overhead during the highest-load period.

### 4.5 The Fix: Remove closePending

The `closePending` state machine was removed entirely from `Connection::Close()` and `Connection::Poll()`. Connections now close immediately regardless of unacked data:

```cpp
void Connection::Close()
{
    switch(state)
    {
    case ConnState::connected:
    case ConnState::otherEndClosed:
    default:
        if (conn)
        {
            netconn_close(conn);
            netconn_delete(conn);
            conn = nullptr;
        }
        FreePbuf();
        SetState(ConnState::free);
        break;
    }
}
```

`netconn_close()` internally calls `tcp_close()`, which flushes pending data and sends a FIN segment. lwIP then manages the TCP close sequence (FIN_WAIT → TIME_WAIT) internally, handling retransmissions as needed. The application code no longer needs to wait for ACKs — lwIP does this autonomously.

The `listener->Notify()` call was also removed from `Close()`, eliminating spurious accept attempts. Notification is retained only in `Terminate()` with `external=true`, where it serves the legitimate purpose of signaling that a connection slot has been freed by RRF's explicit request.

Removed dead code:
- `closeTimer` member variable
- `MaxAckTime` constant (4,000ms)
- `closePending` and `closeReady` state handling in `Poll()`
- `closePending` in `CountConnectionsOnPort()` active connection check

---

## 5. Commit History

All changes were made on the `main` branch on 2026-02-19:

| Commit | Description |
|--------|-------------|
| `bec806c` | Fix closePending race condition and spurious accept notifications |
| `fc57d05` | Fix inverted NETCONN_MORE flag in Connection::Write |
| `315df1b` | Add debug prints for connection lifecycle diagnostics |
| `33032ce` | Add debug build workflow for ESP8266 |
| `8f5f7b6` | Add DEBUG build support for CMake and SocketServer configuration |
| `7d7883e` | Reduce lwIP resource pressure from closePending connections |
| `feb9fe1` | Fix connection robustness issues under memory pressure |
| `0f7b3f0` | Remove blocking delay and stats_display from diagnostics handler |
| `d43e045` | Remove closePending to free lwIP resources immediately on close |

---

## 6. Files Modified

| File | Changes |
|------|---------|
| `src/Connection.cpp` | Write() fixes (NETCONN_MORE, spin loop, return value, ERR_ABRT), Close() simplified (closePending removed, no Notify), Poll() cleaned up, Terminate() null safety and conditional Notify, Connect() return value, Allocate() mutex safety, Report() state text, debug prints |
| `src/Connection.h` | Removed `closeTimer` member, removed `MaxAckTime` constant |
| `src/Listener.cpp` | Stop() use-after-free fix, FTP listener use-after-free fix, backlog drain for rejected connections |
| `src/SocketServer.cpp` | Removed blocking `delay(20)` and `stats_display()` from diagnostics handler, removed unused `lwip/stats.h` include |

---

## 7. Verification

After applying all fixes, the system was tested with the maximum connection load:
- 7 DWC clients actively polling for status updates
- 1 API client
- 1 DWC client simultaneously uploading a file

The file upload completed successfully and survived M122 diagnostics commands (which previously triggered connection collapse via SPI timeouts and/or resource exhaustion). All 8 connections remained stable throughout the test.

---

## 8. Remaining Considerations

### 8.1 `MEMP_NUM_TCP_PCB` Not Explicitly Configured

The ESP8266 lwIP pool size for TCP PCBs defaults to approximately 10, which is not explicitly set in `sdkconfig.defaults.esp8266`. Increasing this value (e.g., to 16 to match `CONFIG_LWIP_MAX_SOCKETS`) would provide more headroom at the cost of additional static memory allocation. With the closePending removal, the current default appears sufficient.

### 8.2 Accept Backlog Size

`Backlog = 8` allows up to 8 pending connections in lwIP's accept queue, each consuming a PCB. Under extreme connection storms, this could still contribute to PCB pressure. Reducing to 2-4 may be warranted if issues resurface.

### 8.3 Debug Output Thread Safety

The `debugPrintf` macro expands to two separate `ets_printf()` calls (file/line prefix, then message body). When multiple FreeRTOS tasks print concurrently, output is garbled. This is a cosmetic issue in DEBUG builds only and does not affect functionality, but it complicates log analysis. A single-call printf wrapper or a mutex-protected logging function would resolve this.

### 8.4 ConnState Enum Unused Values

The `closePending` and `closeReady` values remain in the `ConnState` enum in `MessageFormats.h`. This file defines the SPI protocol shared between the ESP firmware and RepRapFirmware, so the enum values must remain stable for protocol compatibility. The state text array in `Connection::Report()` retains entries for these states to maintain correct indexing.
